#!/bin/bash

export TEXTDOMAIN=rpi-image-tool
export TEXTDOMAINDIR=$PWD/locale

. gettext.sh

# Lib functions




usage() {
	cat <<EOF >&2

EOF

}


#-- Main code

check_root RESULT
if [ $RESULT != 1 ]; then
	echo "Script must be run as root, try: sudo $0"
	exit 1
fi


WORKDIR=
IMAGE=


while getopts ':CMNc:hi:r:s:w:z:' flag ; do
case $flag in
	h)
		usage
		exit 0
;;
C)
FUNCTION=cleanup
;;
M)
FUNCTION=mount
;;
N)
FUNCTION=new
;;
c)
		BLOCKCOUNT=$OPTARG
validate_blockcount $BLOCKCOUNT
;;
i)
IMAGEFILE=$OPTARG
;;
	r)
	ROOTMOUNTPOINT=$OPTARG
validate_mountpoint root $ROOTMOUNTPOINT
		;;
s)
SPLIT=$OPTARG
validate_split ${SPLIT}
;;
	w)
		WORKDIR=$OPTARG
		;;
z)
BLOCKSIZE=$OPTARG
validate_blocksize $BLOCKSIZE
;;
	(?)
		echo "Invalid option" >&2
	usage
			exit 1
;;
	:)
echo "Option -$OPTARG requires an argument." >&2
		usage
exit 1
;;
esac
done



[ -z $WORKDIR ] && { echo "Work directory not set" ; usage; }
if [ $FUNCTION = 'mount' ] || [ $FUNCTION = 'new' ]; then
[ -z "${IMAGEFILE}" ] && { echo "Image file name not set"; usage; }
[ -z $ROOTMOUNTPOINT ] && { echo "Root mount point not set"; usage; }
fi

if [ $FUNCTION = 'new' ]; then
[ -z $BLOCKCOUNT ] && { echo "block count not set" ; usage; }
[ -z $BLOCKSIZE ] && { echo "Blocksize not set"; usage; }
[ -z $SPLIT ] && { echo "Split size not set"; usage; }
fi

case $FUNCTION in
cleanup)
rpi-image-tool -C -w ${WORKDIR}
;;
mount)
rpi-image-tool -w ${WORKDIR} -i ${IMAGEFILE} -r ${ROOTMOUNTPOINT} && imgrsync
;;
new)
rpi-image-tool -N -w $WORKDIR -i ${IMAGEFILE} -r ${ROOTMOUNTPOINT} -c ${BLOCKCOUNT} -z ${BLOCKSIZE} -s ${SPLIT} && rpi-image-sync
;;
esac

exit 0

