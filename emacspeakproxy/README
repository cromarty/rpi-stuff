
This is an Emacspeak server proxy.

It started as an intended connector between Emacspeak and speech-dispatcher,
and it does that job.

However it has grown into a mechanism which can be used for a number of purposes:

* As the intended 'proxy' which will connect Emacspeak to speech-dispatcher

* As a go-between, between Emacspeak and any other speech-synthesis and playback method for which
  a suitable 'back-end' has been written.
    
  * As a way of 'filtering' text to be spoken by Emacspeak, by placing it between Emacspeak
    and the usual Emacspeak servers, for example to perform profanity cleansing.
    
    How it works:
        
    It is written using the techniques usually associated with parsing programming languages at the first stage of
    interpretation or compilation.
    
    A Flex lexer (emspk-sd.l) and a Bison grammar (emspk-sd.y) are used to parse
    input read from standard input.  Input rules follow the published Emacspeak protocol.
    
    Emacspeak protocol instructions are contained on one line each, each line terminated with a newline.
    
As each line is parsed, parameters such as text to be spoken, synthesis settings such as speech rate, punctuation level etc. are
extracted from the stream of tokens and functions are called to process the instruction.

This kind of parsing technique is known to be fast and the syntax of the Flex lexer and Bison grammar are such that modifications
and additions are easier than hard-coding string parsing into an Emacspeak server.

It is possible to use different back-ends as it is relatively trivial to make this part of the process call different functions depending on the purpose of the application.

Parsing example:

The Emacspeak protocol instruction to queue some text for speaking looks like this:

q { Hello world! }

The text between the left and right braces can be anything and there need not be a space after the left brace or before the right brace.  The text might itself contain braces.

In parsing, this is broken into the following chunks:

The instruction: 'q'
A left-brace: '{'
Text to be spoken: Hello world!
A right-brace: '}'
A newline character: ignored but required as a mark that the instruction is finished

All white-space except that between braces is ignored.

When the above protocol 'packet' is received, the text is parsed out of the space between the braces and queued for synthesis.  Synthesis will only take place
if a subsequent 'dispatch' instruction is received from Emacspeak, which takes the form of a 'd' alone on a line.

Another extremely frequent value sent by Emacspeak is:

tts_sync_state xxx n1 n2 n3 n4

Where:

xxx = either 'all', 'some' or 'none'
n1 = a number representing the pitch rise in which to speak capitals.
n2 = a 1 or a zero indicating whether 'all caps beep' is switched on.
n3 = a 1 or a 0 indicating whether or not 'split capitals' is switched on.
n4 = the currently selected speech rate in wpm.

Using the program:

1. To use as a server for Emacspeak, take a look in your .bashrc file.  You should see
a line which reads like this:

export DTK_PROGRAM=xxx

Where 'xxx' is the name of the program you are currently using for speech-synthesis.  Here's what it will look
like if you are using espeak:

export DTK_PROGRAM=espeak

Change this to the name of this server.  If the server binary is not contained in the usual
path to Emacspeak servers, give the full path.
