#!/usr/bin/perl -w

use strict;
use Getopt::Long;

our $KERNELROOT;
our $CCPREFIX;
our $ARCH;
our $PLATFORM;
our $VERBOSE;

my %paths;
my %sets;
my $steps = -1;
my $step;
my $types = 0;
my $type;
my $errors = 0;

my $subs = {
		'check' => \&check_config,
		'build' => \&build_kernel,
		'modules' => \&build_modules,
		'instmod' => \&install_modules,
		'mrproper' => \&mrproper,
		'oldconfig' => \&oldconfig,
		'gzip' => \&gzip_modules
	};

&is_safe("/etc/kbildrc") || die "The master config /etc/kbild is not safe\n";
&is_safe("$ENV{HOME}/.kbildrc") || die "The user config file $ENV{HOME}/.kbildrc is not safe\n";

# user config in /home/user/.kbildrc trumps /etc/kbildrc
do "/etc/kbildrc" || do "$ENV{HOME}/.kbildrc";

# environment values trump both config files
if ($ENV{KERNELROOT}) {
	$KERNELROOT = $ENV{KERNELROOT};
}

if ($ENV{CCPREFIX}) {
	$CCPREFIX = $ENV{CCPREFIX};
}

if ($ENV{ARCH}) {
	$ARCH = $ENV{ARCH};
}

if ($ENV{PLATFORM}) {
	$PLATFORM = $ENV{PLATFORM};
}

if ($ENV{VERBOSE}) {
	$VERBOSE = 1;
}

$paths{'kernelroot'} = $KERNELROOT;

GetOptions (
		'arch=s' => \$ARCH,
	'ccprefix=s' => \$CCPREFIX,
	'platform=s' => \$PLATFORM,
	'kernelroot=s' => \&path_handler,
	'check' => sub { $step = 'check' ; $steps++ },
	'build' => sub { $step = 'build' ; $steps++ },
	'modules' => sub { $step = 'modules' ; $steps++ },
	'instmod' => sub { $step = 'instmod' ; $steps++ }, 
	'mrproper' => sub { $step = 'mrproper' ; $steps++ },
	'oldconfig' => sub { $step = 'oldconfig' ; $steps++ },
	'gzip' => sub { $step = 'gzip' ; $steps++ },
	'cross' => sub { $type = 'cross' ; $types++},
	'native' => sub { $type = 'native' ; $types++ },
	'verbose' => sub { $VERBOSE = 1}
	) || die "There were incorrect arguments\n";

$paths{'build'} = "$paths{'kernelroot'}/build";
$paths{'modules'} = "$paths{'kernelroot'}/modules";
$paths{'src'} = "$paths{'kernelroot'}/src";


die "There were errors\n" if $steps;

$errors++ unless -d $paths{'build'}; # does the build path exist?
$errors++ unless -d $paths{'modules'}; # does the modules path exist?
$errors++ unless -d $paths{'src'}; # does the kernel source path exist?

$errors++ unless -w$paths{'build'}; # do we have write permissions to build path?
$errors++ unless -w $paths{'modules'}; # do we have write permissions to modules path?
$errors++ unless -w $paths{'src'}; # do we have write permissions to kernel source path?

die "There were permission errors\n" if ($errors);

die "There were type errors\n" if $types > 1;



# finally do the command
my $result =&{$subs->{$step}};

#print "Result: $?\n";


#--- subroutines


sub path_handler {
	my ($key, $path) = @_;
	$paths{$key} = "$path";
}

sub check_config {
	
}
sub build_kernel {
	my $cmd = "make ";
	$cmd .= "V=$VERBOSE ";
	$cmd .= "O=$paths{'build'} ";
	if ( $type eq 'cross' ) {
		$cmd .= "CROSS_COMPILE=$CCPREFIX ";
	}
	$cmd .= "-j\$(cat /proc/cpuinfo|grep processor|wc -l) ";
	chdir($paths{'src'});
		return system($cmd);
}

sub build_modules {
	my $cmd = "make ";
	$cmd .= "O=$paths{'build'} ";
 $cmd .= "ARCH=$ARCH ";
	if ( $type eq 'cross' ) {
		$cmd .= "CROSS_COMPILE=$CCPREFIX ";
	}
	$cmd .= "modules";
	chdir($paths{'src'});
		return system($cmd);
	}

sub install_modules {
	my $cmd = "make ";
	$cmd .= "O=$paths{'build'} ";
	$cmd .= "ARCH=$ARCH ";
	if ( $type eq 'cross' ) {
		$cmd .= "CROSS_COMPILE=$CCPREFIX ";
	}
	$cmd .= "INSTALL_MOD_PATH=$paths{'modules'} modules_install";
	chdir($paths{'src'});
	return system($cmd);
}

sub mrproper {
	my $cmd = "make ";
	$cmd .= "O=$paths{'build'} ";
 	$cmd .= "mrproper";
	chdir($paths{'src'});
	return system($cmd);
}

sub oldconfig {
	my $cmd = "make ";
	$cmd .= "V=$VERBOSE ";
	$cmd .= "O=$paths{'build'} ";
	$cmd .= "ARCH=$ARCH ";
	$cmd .= "oldconfig";
chdir($paths{'src'});
	return system($cmd);
}



sub gzip_modules {
	my $result;
	chdir("$paths{'modules'}");
	$result = system("find . -name '*.ko' -exec gzip -9 {} \\;");
	return $result unless $result == 0;
	return system("find . -name '*.ko' -exec rm {} \\;");
}


sub usage() {
	print <<EOF;

Usage: kbild [options]
	[ --arch ARCH ][ --ccprefix CCPREFIX ][ --platform PLATFORM ][ --kernelroot KERNELROOT ] \
	[ --verbose ] \
	{ --check | --build | --modules | --instmod | --mrproper | --oldconfig | --gzip ] \
	{ --cross | --native }

Options:
	--arch ARCH: Set architecture to ARCH. Only relevant for --cross cross-compile
	--ccprefix CCPREFIX Set the prefix path to the cross-compiler.  Only relevant for --cross cross-compile
	--platform PLATFORM Set the platform value to PLATFORM. Only relevant for --cross cross-compile
	--kernelroot KERNELROOT Set the path to the kernel root to KERNELROOT

	--check Check the configuration is correct and everything is where it should be.  Don't process anything else
	--build Compile kernel
	--modules Compile the kernel modules
	--instmod Install kernel modules
	--mrproper Run mrproper to clean build environment
	--oldconfig Run oldconfig to initialize config file
	--gzip Run gzip to compress kernel modules (where relevant to kernel config)

	--cross Cross-compile
	--native Native compile (not a cross-compile)

	--verbose Set verbosity to true (more verbose)

Notes:
	User must have write permissions to KERNEL_ROOT/build and KERNEL_ROOT/modules

EOF
}

sub is_safe {
	my $path = shift;
	my $info = stat($path);
	return 1 unless -e $path;
	return unless $info;

	# owner neither superuser nor me 
	# the real uid is in stored in the $< variable
	if (($info->uid != 0) && ($info->uid != $<)) {
		return 0;
	}

	# check whether group or other can write file.
	# use 066 to detect either reading or writing
	if ($info->mode & 022) {   # someone else can write this file
		return 0 unless -d _;
		# non-directories aren't safe
		# but directories with the sticky bit (01000) are
		return 0 unless $info->mode & 01000;        
	}

	# all is safe
	return 1;
}

