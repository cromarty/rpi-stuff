#!/bin/bash

. ./imgtool.lib


usage() {
	cat <<EOF >&2

Usage: imgtool [OPTIONS}

	Options:

		-C

			Perform a 'clean-up' of previous Mount/New run.

		-M

			Perform a MOUNT operation, see other options below.

		-N

			Perform a NEW operation, see other options below.

		-c

			Block-count. Number of (BLOCKSIZE -z) blocks to write to a (NEW -N) image 
			file. Mandatory for a -N operation.

		-i

			Name of the image file to either MOUNT (-M) or create (-N). Full path, mandatory for either a MOUNT or NEW operation.

		-r

			Name of the directory which will be the mount-point (within the work 
			directory, see below) for MOUNT or NEW operation.

		-s

			Split. Number of blocks of size -z (see below) which will form the size of 
			the FAT32 boot partition for a NEW (-N) image file.

			The root partition (second partition) will begin from this position.

			Mandatory in a NEW (-N) operation.

		-w

			The work directory in which to work, relative to the CWD. It will be created 
			if it doesn't exist.

			Mandatory for all (-C, -M, -N) operations.

		-z

			Block-size to be used in a NEW (-N) operation to create a new image.

			Valid values are '1M' or '1MB'. See 'dd' manual page.

			Mandatory for a NEW (-N) operation.

Examples:

		Create a new image file and mount the two partitions:

			$ imgtool -N -w work -i work/newimage.img -c 2000 -s 64 -z 1M -r rootmp

			The above will create an image file of 2000 1M blocks in size with the split 
			of 64 blocks, in the 'work' directory, and mount the root partion at 
'work/rootmp'.

			Note that the FAT32 boot partition will be mounted on a directory called 
			'boot' which is created by imgtool under the root mount-point (-r).

		Mount an existing image:

			$ imgtool -M -w work -i oldimage.img -r rootmp

			The above will create the work directory 'work', and mount the pre-existing 
			image file 'oldimage.img' using the root mount-point 'rootmp'.

			As in the NEW operation, the boot (FAT32) partition is mounted on 
			<rootmp>/boot.

		Clean-up:

			$ imgtool -C -w work

			The above will perform a clean-up for a previous MOUNT (-M) or NEW (-N) 
			operation. These are the steps:

			* umount both partitions.
			* Remove both partition mount-points.
				* Remove both the loop-devices used in the previous operation.
			* Remove both working files:
				imgtool-loop-dev-names
				imgtool-mount-points

EOF


}



read_rc_file() {
    local __BLOCKCOUNT=${1}
    local __BLOCKSIZE=${2}
    local __ROOTMOUNTPOINT=${3}
    local __FUNCTION=${4}

if [ -f ~/.imgtoolrc ]; then
	source ~/.imgtoolrc
else
if [ -f /etc/imgtoolrc ]; then
		source /etc/imgtoolrc
fi
fi

eval $__BLOCKCOUNT="'$BLOCKCOUNT'"
	eval $__BLOCKSIZE="'$BLOCKSIZE'"
eval $__ROOTMOUNTPOINT="'$ROOTMOUNTPOINT'"
eval $__FUNCTION="'$FUNCTION'"
}

validate_blockcount() {
echo "$BLOCKCOUNT" | grep "^[0-9][0-9]*$" >/dev/null
if [ $? -eq 1 ]; then
		echo 'Bad block count'
		usage
fi
}

validate_mountpoint() {
declare -r point=${1}
declare -r MOUNTPOINT=${2}
	echo $MOUNTPOINT | grep "^[\./A-Za-z0-9][\.A-Za-z0-9]*" >/dev/null
if [ $? -eq 1 ]; then
echo "Bad $point mount point"
	exit 1
fi
}

validate_blocksize() {
	declare -r BLOCKSIZE=${1}
case "$BLOCKSIZE" in
	'1M'|'1MB')
	;;
	*)
		echo 'Invalid block-size'
		usage
		exit 1
	;;
esac
    
}

validate_split() {
local SPLIT=${1}
echo "${SPLIT}" | grep "^[0-9][0-9]*$" >/dev/null
if [ $? -eq 1 ]; then
echo "Bad split"
usage
fi
}

#-- Main code

check_root RESULT
if [ $RESULT != 1 ]; then
	echo "Script must be run as root, try: sudo $0"
	exit 1
fi


WORKDIR=
IMAGE=

read_rc_file BLOCKCOUNT BLOCKSIZE ROOTMOUNTPOINT FUNCTION 

while getopts ':CMNc:hi:r:s:w:z:' flag ; do
case $flag in
	h)
		usage
		exit 0
;;
C)
FUNCTION=cleanup
;;
M)
FUNCTION=mount
;;
N)
FUNCTION=new
;;
c)
		BLOCKCOUNT=$OPTARG
validate_blockcount $BLOCKCOUNT
;;
i)
IMAGEFILE=$OPTARG
;;
	r)
	ROOTMOUNTPOINT=$OPTARG
validate_mountpoint root $ROOTMOUNTPOINT
		;;
s)
SPLIT=$OPTARG
validate_split ${SPLIT}
;;
	w)
		WORKDIR=$OPTARG
		;;
z)
BLOCKSIZE=$OPTARG
validate_blocksize $BLOCKSIZE
;;
	(?)
		echo "Invalid option" >&2
	usage
			exit 1
;;
	:)
echo "Option -$OPTARG requires an argument." >&2
		usage
exit 1
;;
esac
done



[ -z $WORKDIR ] && { echo "Work directory not set" ; usage; }
if [ $FUNCTION = 'mount' ] || [ $FUNCTION = 'new' ]; then
[ -z "${IMAGEFILE}" ] && { echo "Image file name not set"; usage; }
[ -z $ROOTMOUNTPOINT ] && { echo "Root mount point not set"; usage; }
fi

if [ $FUNCTION = 'new' ]; then
[ -z $BLOCKCOUNT ] && { echo "block count not set" ; usage; }
[ -z $BLOCKSIZE ] && { echo "Blocksize not set"; usage; }
[ -z $SPLIT ] && { echo "Split size not set"; usage; }
fi



case $FUNCTION in
cleanup)
clean_up ${WORKDIR} ${ROOTMP}
;;
mount)
mount_image ${WORKDIR} ${IMAGEFILE} ${ROOTMOUNTPOINT}
;;
new)
new_image $WORKDIR ${IMAGEFILE} ${ROOTMOUNTPOINT} ${BLOCKCOUNT} ${BLOCKSIZE} ${SPLIT}
;;
esac

exit 0


