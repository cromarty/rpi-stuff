#!/bin/bash
#
# imgtool.sh
# Copyright (C) 2016 Mike Ray <mike.ray@btinternet.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# This code is supplied as is and without any guarantees of fitness for purpose and without liability either stated
# or implied.
#
# You will need losetup and kpartx.
#


usage() {

	cat <<eof

Usage:

-h | --help Usage

     Display this usage message and exit.

-d | --dryrun

     Perform a dry-run but actually do nothing. All other parameters still as required.

-f | --func { mount|new|cleanup} Function

     mount = Mount a previously created image file.
          new = Create and mount a new image (.img) file.
          cleanup = Un-mount img partitions, remove the loop devices and remove the mount-points

-i | --image Image file name file

     Name of the image file to create/mount. Mandatory.
     
-w | --workdir Work directory

     Name of the working directory. Mandatory.
     
-b | --bootmp Boot mount point

     Name of the mount-point where the boot partition of the image file will be mounted.

     Default = 'bootmp'
     
-r | --rootmp Root mount point

     Name of the mount-point where the root partition of the image file will be mounted.
     
          Default = 'rootmp'

-c | --bcount Block count

     Number of blocks to allocate for a new image file. Mandatory.

-z | --bsize Block size

          Block-size for the dd command.

     Default = '1M'.

-s | --split Split

     Split between boot and root partition, will be size of boot partition in number of blocks.

     Default = 64.

eof
  
	exit 1
} # end usage

checkargs() {
	if [ $# -lt 2 ]; then
		usage
	fi
} # end check_args

loop_devices() {
    
	echo "Setting up the loop device..."
	LOOPDEVICE=`losetup -f --show ${IMAGEFILE}`
	DEVICE=`kpartx -va ${LOOPDEVICE} | sed -E 's/.*(loop[0-9][0-9]*)p.*/\1/g' | head -1`
	DEVICE="/dev/mapper/${DEVICE}"
	BOOTP=${DEVICE}p1
	ROOTP=${DEVICE}p2

} # end loop_devices

mount_partitions() {

	echo "Making the mount points if they don't exist..."
	[ -d ${BOOTMP} ] || mkdir -p "${BOOTMP}"
	[ -d ${ROOTMP} ] || mkdir -p "${ROOTMP}"

	echo "Writing mount-points to ${WORKDIR}/mount-points"
	echo -e "${BOOTMP}\n${ROOTMP}" > ${WORKDIR}/mount-points
	
	echo "Mounting the two partitions..."
	mount ${BOOTP} ${BOOTMP}
	mount ${ROOTP} ${ROOTMP}

} # end mount_partitions

    
new_image() {

	echo "Making the work directory if it doesn't exist..."
	[ -d ${WORKDIR} ] || mkdir -p "${WORKDIR}"

	echo "Running dd to make a raw (zero-filled) image"
	dd if=/dev/zero of=${IMAGEFILE} bs=${BLOCKSIZE} count=${BLOCKCOUNT}

	echo "Partitioning the raw image file..."
	parted ${IMAGEFILE} --script -- mklabel msdos
	echo 'Making the boot partition...'
	parted ${IMAGEFILE} --script -- mkpart primary fat32 1 ${SPLIT}
	echo 'Setting the boot partition bootable...'
	parted ${IMAGEFILE} --script set 1 boot on
	echo 'Making the root partition...'
	parted ${IMAGEFILE} --script -- mkpart primary ext4 ${SPLIT} -1

	loop_devices
	
	echo "Writing loop device names to ${WORKDIR}/loop-dev-names"
		echo -e "${BOOTP}\n${ROOTP}" > "${WORKDIR}/loop-dev-names"

	echo "Boot partition is ${BOOTP}"
	echo "Root partition is ${ROOTP}"

	sleep 5

	echo "Making file systems..."
	mkfs.vfat ${BOOTP}
	mkfs.ext4 ${ROOTP}

	mount_partitions

} # end new_image

mount_image() {

	echo "Making the work directory if it doesn't exist..."
	[ -d ${WORKDIR} ] || mkdir -p "${WORKDIR}"

	loop_devices

	sleep 5

	mount_partitions

		echo "Writing loop device names to ${WORKDIR}/loop-dev-names"
		echo -e "${BOOTP}\n${ROOTP}" > "${WORKDIR}/loop-dev-names"
		
} # end mount_image

validate_blocksize() {
case "$BLOCKSIZE" in
	'1M'|'1MB')
	;;
	*)
		echo 'Invalid block-size'
		usage
		exit 1
	;;
esac
    
} # end validate_blocksize

validate_blockcount() {
echo "$BLOCKCOUNT" | grep "^[0-9][0-9]*$" >/dev/null
if [ $? -eq 1 ]; then
		echo 'Bad block count'
		usage
fi
} # end validate_blockcount


validate_split() {
echo "${SPLIT}" | grep "^[0-9][0-9]*$" >/dev/null
if [ $? -eq 1 ]; then
		echo 'Bad split value'
		usage
fi
} # end validate_split


remove_loop_devices() {
	
	echo 'Removing loop devices...'
	[ -f ${WORKDIR}/loop-dev-names ] || { echo "${WORKDIR}/loop-dev-names does not exist" ; exit 1 ; }
	cat ${WORKDIR}/loop-dev-names | \
	while read LOOP
	do
		echo "Removing loop device ${LOOP}..."
		dmsetup remove ${LOOP}
	done
	
} # end remove_loop_devices


remove_mount_points() {

	[ -f ${WORKDIR}/mount-points ] || { echo "${WORKDIR}/mount-points does not exist" ; exit 1 ; }
	cat ${WORKDIR}/mount-points | \
	while read MOUNTPOINT
	do
	    echo "rmdir-ing ${MOUNTPOINT}"
		rmdir ${MOUNTPOINT}
	done

} # end remove_mount_points

un_mount_partitions() {
	
	echo 'Un-mounting partitions...'
	cat ${WORKDIR}/mount-points | \
	while read MOUNTPOINT
	do
	      echo "umount-ing ${MOUNTPOINT}"
		umount "${MOUNTPOINT}"
	done
	
} # end un_mount_partitions

clean_up() {

	un_mount_partitions ${WORKDIR}
	remove_mount_points ${WORKDIR}
	remove_loop_devices ${WORKDIR}

	rm ${WORKDIR}/mount-points
	rm ${WORKDIR}/loop-dev-names

} # end clean_up


check_root() {
	if [ `whoami` != 'root' ]; then
		echo "Script must be run as root, try 'sudo $0'"
		exit 1
	fi

} # end check_root

#-- main code

set -e

BLOCKSIZE=1M
BOOTMP=bootmp
ROOTMP=rootmp
SPLIT=64
DRYRUN=

while :
do
	case "$1" in
		-b | --bootmp)
			checkargs $*
			BOOTMP="$2"
			shift 2
		;;
		-r | --rootmp)
			checkargs $*
			ROOTMP="$2"
			shift 2
		;;
		-c | --bcount)
			checkargs $*
			BLOCKCOUNT="$2"
			shift 2
		;;
		-z | --bsize)
			checkargs $*
			BLOCKSIZE="$2"
			shift 2
		;;
		-h | --help)
			usage
			# no shifting needed here, we're done.
			exit 0
		;;
		-d|--dryrun)
			DRYRUN=1
			shift
		;;
		-i | --image)
			checkargs $*
			IMAGEFILE="$2"
			shift 2
		;;
		-s | --split)
			checkargs $*
			SPLIT="${2}"
			shift 2
		;;
		-w | --workdir)
			checkargs $*
			WORKDIR=${2}
			shift 2
		;;
		-f | --func)
			FUNC=${2}
			shift 2
		;;
		--)
			shift
			break;
		;;
		-*)
			echo "Error: Unknown option: $1" >&2
			usage
			exit 1
		;;
		*)
			break
		;;
	esac

done

check_root

[ -z "$WORKDIR" ] && { echo 'No working directory supplied' ; usage ; }
[ -z "$FUNC" ] && { echo 'No function supplied' ; usage ; }


WORKDIR=$(realpath ${WORKDIR})

BOOTMP=${WORKDIR}/${BOOTMP}
ROOTMP=${WORKDIR}/${ROOTMP}


case "$FUNC" in
	'mount')
		[ -z "$IMAGEFILE" ] && { echo 'Image file name is missing' ; usage ; }
		[ -f "${IMAGEFILE}" ] || { echo 'Image file does not exist' ; exit 1 ; }  
		IMAGEFILE=$(realpath ${IMAGEFILE})
		mount_image
	;;
	'new')
		[ -z "$BLOCKCOUNT" ] && { echo 'No block-count supplied' ; usage ; }
		[ -z "$BLOCKSIZE" ] && { echo 'No block-size supplied' ; usage ; }
		[ -z "$SPLIT" ] && { echo 'No split-size supplied' ; usage ; }
		[ -z "$IMAGEFILE" ] && { echo 'Image file name is missing' ; usage ; }
		[ -f "${IMAGEFILE}" ] && { echo 'Image file already exists, not overwriting' ; exit 1 ; }  
		validate_blockcount
		validate_blocksize
		validate_split
		IMAGEFILE=$(realpath ${IMAGEFILE})
		new_image
	;;
	'cleanup')
		clean_up
	;;
	*)
		echo 'Invalid function'
		usage
		exit 1
	;;
esac

echo "All done"
exit 0
