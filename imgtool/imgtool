#!/bin/bash
#
# imgtool.sh
# Copyright (C) 2016 Mike Ray <mike.ray@btinternet.com>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# This code is supplied as is and without any guarantees of fitness for purpose and without liability either stated
# or implied.
#
# You will need losetup and kpartx.
#


usage() {

	cat <<eof

Usage:

-h | --help Usage

     Display this usage message and exit.

-d | --dryrun

     Perform a dry-run but actually do nothing. All other parameters still as required.

-f | --func { mount|new|cleanup} Function

     mount = Mount a previously created image file.
          new = Create and mount a new image (.img) file.
          cleanup = Un-mount img partitions, remove the loop devices and remove the mount-points

-i | --image Image file name file

     Name of the image file to create/mount. Mandatory.
     
-w | --workdir Work directory

     Name of the working directory. Mandatory.
     
-b | --bootmp Boot mount point

     Name of the mount-point where the boot partition of the image file will be mounted.

     Default = 'bootmp'
     
-r | --rootmp Root mount point

     Name of the mount-point where the root partition of the image file will be mounted.
     
          Default = 'rootmp'

-c | --bcount Block count

     Number of blocks to allocate for a new image file. Mandatory.

-z | --bsize Block size

          Block-size for the dd command.

     Default = '1M'.

-s | --split Split

     Split between boot and root partition, will be size of boot partition in number of blocks.

     Default = 64.

eof

  
	exit 1
} # end usage

checkargs() {
	if [ $# -lt 2 ]; then
		usage
	fi
} # end check_args


new_image() {
	local WORKDIR=$(realpath ${1})
	local IMAGEFILE=$(realpath $1)/$(basename ${2})
	local BLOCKSIZE=${3}
	local BLOCKCOUNT=${4}
	local SPLIT=${5}
	local BOOTMP=$(realpath $1)/$(basename ${6})
	local ROOTMP=$(realpath $1)/$(basename ${7})

	if [ ${DRYRUN} ]; then
		echo -e "Dry-run:\n\n"
		echo "Function (FUNC)           = new"
		echo "Work directory (WORKDIR)  = ${WORKDIR}"
		echo "Image file (IMAGEFILE)    = ${IMAGEFILE}"
		echo "Block size (BLOCKSIZE)    = ${BLOCKSIZE}"
		echo "Block count (BLOCKCOUNT)  = ${BLOCKCOUNT}"
		echo "Boot mount-point (BOOTMP) = ${BOOTMP}"
		echo "Root mount-point (ROOTMP) = ${ROOTMP}"
		exit 0
		fi

	set -e

	echo "Making the work directory if it doesn't exist..."
	[ -d ${WORKDIR} ] || mkdir -p "${WORKDIR}"

	echo "Running dd to make a raw (empty) image file of ${BLOCKCOUNT} ${BLOCKSIZE} blocks, this will take about 30 seconds, depending on the speed of your machine..."
	dd if=/dev/zero of=${IMAGEFILE} bs=${BLOCKSIZE} count=${BLOCKCOUNT}

	echo "Partitioning the raw image file..."
	parted ${IMAGEFILE} --script -- mklabel msdos
	echo 'Making the boot partition...'
	parted ${IMAGEFILE} --script -- mkpart primary fat32 1 ${SPLIT}
	echo 'Setting the boot partition bootable...'
	parted ${IMAGEFILE} --script set 1 boot on
	echo 'Making the root partition...'
	parted ${IMAGEFILE} --script -- mkpart primary ext4 ${SPLIT} -1

	echo "Setting up the loop device..."
	LOOPDEVICE=`losetup -f --show ${IMAGEFILE}`
	DEVICE=`kpartx -va ${LOOPDEVICE} | sed -E 's/.*(loop[0-9][0-9]*)p.*/\1/g' | head -1`
	DEVICE="/dev/mapper/${DEVICE}"

	BOOTP=${DEVICE}p1
	ROOTP=${DEVICE}p2

	echo "Boot partition is ${BOOTP}"
	echo "Root partition is ${ROOTP}"

	echo -e "${BOOTP}\n${ROOTP}" > ${WORKDIR}/loop-dev-names

	sleep 5

	echo "Making file systems..."
	mkfs.vfat ${BOOTP}
	mkfs.ext4 ${ROOTP}

	echo "Making the mount points if they don't exist..."
	if [ ! -d ${BOOTMP} ]; then
		mkdir -p ${BOOTMP}
	fi

	if [ ! -d ${ROOTMP} ]; then
		mkdir -p ${ROOTMP}
	fi

	echo -e "${BOOTMP}\n${ROOTMP}" > ${WORKDIR}/mount-points

	echo "Mounting the two partitions..."
	mount ${BOOTP} ${BOOTMP}
	mount ${ROOTP} ${ROOTMP}

	echo 'Finished'

} # end new_image

mount_image() {
	local WORKDIR=$(realpath $1)
	local IMAGEFILE=$(realpath $2)
	local BOOTMP=$(realpath $1)/$3
	local ROOTMP=$(realpath $1)/$4

	if [ ${DRYRUN} ]; then
		echo -e "Dry-run:\n\n"
		echo "Function (FUNC)           = mount"
		echo "Work directory (WORKDIR)  = ${WORKDIR}"
		echo "Image file (IMAGEFILE)    = ${IMAGEFILE}"
		echo "Boot mount-point (BOOTMP) = ${BOOTMP}"
		echo "Root mount-point (ROOTMP) = ${ROOTMP}"
		exit 0
	fi


	set -e

	echo "Making the work directory if it doesn't exist..."
	if [ ! -d ${WORKDIR} ]; then
		mkdir -p "${WORKDIR}"
	fi

	echo "Setting up the loop device..."
	LOOPDEVICE=`losetup -f --show ${IMAGEFILE}`
	DEVICE=`kpartx -va ${LOOPDEVICE} | sed -E 's/.*(loop[0-9][0-9]*)p.*/\1/g' | head -1`
	DEVICE="/dev/mapper/${DEVICE}"

	BOOTP=${DEVICE}p1
	ROOTP=${DEVICE}p2

	echo "Boot partition is ${BOOTP}"
	echo "Root partition is ${ROOTP}"

	echo -e "${BOOTP}\n${ROOTP}" > ${WORKDIR}/loop-dev-names

	sleep 5

	echo "Making the mount points if they don't exist..."
	if [ ! -d ${BOOTMP} ]; then
		mkdir -p ${BOOTMP}
	fi

	if [ ! -d ${ROOTMP} ]; then
		mkdir -p ${ROOTMP}
	fi

	echo ${BOOTMP} > ${WORKDIR}/mount-points
	echo ${ROOTMP} >> ${WORKDIR}/mount-points

	echo "Mounting the two partitions..."
	mount ${BOOTP} ${BOOTMP}
	mount ${ROOTP} ${ROOTMP}

	echo 'Finished'

} # end mount_image

validate_blocksize() {
	local BLOCKSIZE=$1

case "$BLOCKSIZE" in
	'1M')
	;;
	'1MB')
		;;
	*)
		echo 'Invalid block-size'
		usage
		exit 1
	;;
esac
    
} # end validate_blocksize

validate_blockcount() {
	local BLOCKCOUNT=$1

echo "$BLOCKCOUNT" | grep "^[0-9][0-9]*$" >/dev/null
if [ $? -eq 1 ]; then
		echo 'Bad block count'
		usage
fi
} # end validate_blockcount


validate_split() {
    local SPLIT=$1

echo "${SPLIT}" | grep "^[0-9][0-9]*$" >/dev/null
if [ $? -eq 1 ]; then
		echo 'Bad split value'
		usage
fi
} # end validate_split


remove_loop_devices() {
	local WORKDIR=$(realpath $1)

	set +e
	echo 'Removing loop devices...'
	[ -f ${WORKDIR}/loop-dev-names ] || { echo "${WORKDIR}/loop-dev-names does not exist" ; exit 1 ; }
	cat ${WORKDIR}/loop-dev-names | \
	while read LOOP
	do
		echo "Removing loop device ${LOOP}..."
		dmsetup remove ${LOOP}
	done

} # end remove_loop_devices


remove_mount_points() {
	local WORKDIR=$(realpath $1)

	set +e
	echo 'Removing mount points...'
	[ -f ${WORKDIR}/mount-points ] || { echo "${WORKDIR}/mount-points does not exist" ; exit 1 ; }
	cat ${WORKDIR}/mount-points | \
	while read MOUNTPOINT
	do
		rmdir ${MOUNTPOINT}
	done

} # end remove_mount_points

un_mount_partitions() {
	local WORKDIR=$(realpath $1)
	local MOUNTPOINTS=${WORKDIR}/mount-points

	set +e
	echo 'Un-mounting partitions...'
	cat ${MOUNTPOINTS} | \
	while read MOUNTPOINT
	do
		umount ${MOUNTPOINT}
	done

} # end un_mount_partitions

clean_up() {
	local WORKDIR=$(realpath $1)

	if [ ${DRYRUN} ]; then
		echo -e "Dry-run:\n\n"
		echo "Function (FUNC) = cleanup"
		echo "Work directory (WORKDIR) = ${WORKDIR}"
		exit 0
	fi

	un_mount_partitions ${WORKDIR}
	remove_mount_points ${WORKDIR}
	remove_loop_devices ${WORKDIR}

	rm ${WORKDIR}/mount-points
	rm ${WORKDIR}/loop-dev-names

} # end clean_up


check_root() {
	if [ `whoami` != 'root' ]; then
		echo "Script must be run as root, try 'sudo $0'"
		exit 1
	fi

} # end check_root

#-- main code

BLOCKSIZE=1M
BOOTMP=bootmp
ROOTMP=rootmp
SPLIT=64
DRYRUN=


while :
do
	case "$1" in
		-b | --bootmp)
			checkargs $*
			BOOTMP="$2"
			shift 2
		;;
		-r | --rootmp)
			checkargs $*
			ROOTMP="$2"
			shift 2
		;;
		-c | --bcount)
			checkargs $*
			BLOCKCOUNT="$2"
			shift 2
		;;
		-z | --bsize)
			checkargs $*
			BLOCKSIZE="$2"
			shift 2
		;;
		-h | --help)
			usage
			# no shifting needed here, we're done.
			exit 0
		;;
		-d|--dryrun)
			DRYRUN=1
			shift
		;;
		-i | --image)
			checkargs $*
			IMAGEFILE=$(realpath "$2")
			shift 2
		;;
		-s | --split)
			checkargs $*
			SPLIT="${2}"
			shift 2
		;;
		-w | --workdir)
			checkargs $*
			WORKDIR=$(realpath "${2}")
			shift 2
		;;
		-f | --func)
			FUNC=${2}
			shift 2
		;;
		--)
			shift
			break;
		;;
		-*)
			echo "Error: Unknown option: $1" >&2
			usage
			exit 1
		;;
		*)
			break
		;;
	esac

done

check_root

[ -z "$WORKDIR" ] && { echo 'No working directory supplied' ; usage ; }
[ -z "$FUNC" ] && { echo 'No function supplied' ; usage ; }

case "$FUNC" in
	'mount')
		[ -z "$IMAGEFILE" ] && { echo 'Image file name is missing' ; usage ; }
		[ -f "${IMAGEFILE}" ] || { echo 'Image file does not exist' ; exit 1 ; }  
		mount_image ${WORKDIR} ${IMAGEFILE} ${BOOTMP} ${ROOTMP}
	;;
	'new')
		[ -z "$IMAGEFILE" ] && { echo 'Image file name is missing' ; usage ; }
		[ -z "$BLOCKCOUNT" ] && { echo 'No block-count supplied' ; usage ; }
		[ -z "$BLOCKSIZE" ] && { echo 'No block-size supplied' ; usage ; }
		[ -z "$SPLIT" ] && { echo 'No split-size supplied' ; usage ; }
		validate_blockcount ${BLOCKCOUNT}
		validate_blocksize ${BLOCKSIZE}
		validate_split ${SPLIT}
		new_image ${WORKDIR} ${IMAGEFILE} ${BLOCKSIZE} ${BLOCKCOUNT} ${SPLIT} ${BOOTMP} ${ROOTMP}
	;;
	'cleanup')
		clean_up ${WORKDIR}
	;;
	*)
		echo 'Invalid function'
		usage
		exit 1
	;;
esac

exit 0
